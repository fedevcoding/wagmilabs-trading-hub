generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model block {
  block_number      Int      @id
  timestamp         DateTime @db.Timestamptz(6)
  block_hash        String   @unique
  parent_hash       String
  nonce             String
  miner             String
  difficulty        BigInt
  base_fee_per_gas  Float?
  gas_limit         Int
  gas_used          Int
  transaction_count Int

  @@index([block_number])
  @@index([timestamp])
}

// model bid {
//   id               String   @id
//   status           String
//   contract_address String
//   maker            String
//   value            Float
//   currency         String
//   valid_from       DateTime @db.Timestamptz(6)
//   valid_until      DateTime @db.Timestamptz(6)
//   expiration       DateTime @db.Timestamptz(6)
//   quantity         Int
//   quantity_filled  Int
//   kind             String
//   kind_id          String
//   marketplace      String
//   updated_at       DateTime @default(now()) @db.Timestamptz(6)
// }

model collection {
  id                      String                    @id
  contract_address        String                    @unique
  image                   String?                   @default("https://storage.googleapis.com/opensea-static/opensea-profile/10.png")
  name                    String?
  banner                  String?
  total_supply            Int
  unique_owners           Int?
  description             String?
  floor_price             Float?
  floor_price_currency    String?
  slug                    String?
  created_at              DateTime                  @db.Timestamptz(6)
  opensea_verificated     Boolean
  top_bid                 Float?
  top_bid_currency        String?
  opensea_royalties       Float?
  twitter                 String?
  discord                 String?
  website                 String?
  updated_at              DateTime                  @default(now()) @db.Timestamptz(6)
  erc_type                erc_type
  creator                 String?
  collection_floor_change collection_floor_change[]
  listing                 listing[]
  mint                    mint[]
  sale                    sale[]
  token                   token[]
  transfer                transfer[]

  @@index([contract_address])
  @@index([name])
}

model listing {
  id                 String         @id
  contract_address   String
  token_id           String
  valid_from         DateTime?      @db.Timestamptz(6) // when listing was created
  valid_until        DateTime?      @db.Timestamptz(6) // updatable // when listing was set to expire
  expiration         DateTime?      @db.Timestamptz(6) // updatable // when listing was expired (if it was expired/cancelled/inactive) or when it's set to expire
  marketplace        String
  value              Float
  order_hash         String         @unique
  maker              String
  status             listing_status // updatable
  quantity           Int
  quantity_remaining Int // updatable
  updated_at         DateTime       @default(now()) @db.Timestamptz(6) // updatable
  currency           String
  collection         collection     @relation(fields: [contract_address], references: [contract_address])

  @@index([contract_address, status])
  @@index([contract_address, token_id])
  @@index([contract_address, valid_from])
  @@index([contract_address, value])
  @@index([maker, valid_from])
  @@index([marketplace])
  @@index([valid_from])
  @@index([order_hash])
  @@index([maker])
}

model mint {
  id               String     @id
  block_number     Int
  contract_address String
  operator_address String
  token_id         String
  transaction_hash String
  timestamp        DateTime   @db.Timestamptz(6)
  is_batch         Boolean
  batch_size       Int?
  batch_index      Int?
  total_value      Float
  value            Float
  quantity         String
  minter_address   String
  transaction_fee  Float?
  log_index        Int
  erc_type         erc_type
  collection       collection @relation(fields: [contract_address], references: [contract_address])

  @@unique([contract_address, token_id, transaction_hash, minter_address])
  @@index([contract_address, timestamp])
  @@index([operator_address])
  @@index([contract_address, token_id])
  @@index([contract_address, value])
  @@index([transaction_hash])
  @@index([block_number])
  @@index([erc_type])
  @@index([timestamp])
  @@index([log_index])
}

model transfer {
  id               String        @id
  block_number     Int
  contract_address String
  operator_address String
  token_id         String
  transaction_hash String
  timestamp        DateTime      @db.Timestamptz(6)
  is_batch         Boolean
  batch_size       Int?
  batch_index      Int?
  from             String
  to               String
  amount           String
  transaction_fee  Float?
  log_index        Int
  type             transfer_type
  erc_type         erc_type
  collection       collection    @relation(fields: [contract_address], references: [contract_address])

  @@unique([contract_address, token_id, transaction_hash, from, to])
  @@index([contract_address, type])
  @@index([contract_address, timestamp])
  @@index([operator_address])
  @@index([contract_address, token_id])
  @@index([transaction_hash])
  @@index([block_number])
  @@index([timestamp])
  @@index([log_index])
  @@index([erc_type])
  @@index([from])
  @@index([type])
  @@index([to])
}

model collection_floor_change {
  id                   String     @id
  contract_address     String
  timestamp            DateTime   @db.Timestamptz(6)
  floor_price          Float?
  previous_floor_price Float?
  event_id             String     @unique
  collection           collection @relation(fields: [contract_address], references: [contract_address])

  @@index([contract_address])
  @@index([contract_address, timestamp])
  @@index([timestamp])
}

model token {
  id String @id

  total_supply String // updatable PROBLEM

  remaining_supply String // updatable PROBLEM
  total_burns      String // updatable PROBLEM

  owner String? // updatable PROBLEM

  contract_address String
  token_id         String
  name             String? // updatable
  description      String? // updatable
  image            String? // updatable
  media            String? // updatable
  rarity_rank      Int? // updatable
  erc_type         erc_type
  is_flagged       Boolean              @default(false) // updatable
  collection       collection           @relation(fields: [contract_address], references: [contract_address])
  attribute        AttributesOnTokens[]

  @@unique([contract_address, token_id])
  @@index([contract_address])
  @@index([contract_address, token_id])
  @@index([token_id])
  @@index([name])
  @@index([owner])
}

// DELETABLE
model attribute {
  id               String               @id
  contract_address String
  key              String
  value            String
  token            AttributesOnTokens[]

  @@unique([contract_address, key, value])
  @@index([contract_address])
  @@index([contract_address, key])
  @@index([id])
}

model AttributesOnTokens {
  token_id     String
  attribute_id String
  token        token     @relation(fields: [token_id], references: [id])
  attribute    attribute @relation(fields: [attribute_id], references: [id])

  @@id([token_id, attribute_id])
  @@index([token_id])
  @@index([attribute_id])
}

model sale {
  id               String     @id
  sale_id          String     @unique
  block_number     Int
  contract_address String
  token_id         String
  transaction_hash String
  timestamp        DateTime   @db.Timestamptz(6)
  marketplace      String
  value            Float
  currency         String
  quantity         String
  order_hash       String?
  from             String
  to               String
  sale_type        sale_type
  collection       collection @relation(fields: [contract_address], references: [contract_address])

  @@index([contract_address, timestamp])
  @@index([contract_address, token_id])
  @@index([contract_address, value])
  @@index([timestamp])
  @@index([transaction_hash])
}

model owners {
  id               String @id
  contract_address String
  token_id         String
  owner            String
  quantity         String

  @@unique([contract_address, owner, token_id])
  @@index([contract_address])
  @@index([contract_address, owner])
  @@index([owner])
  @@index([quantity])
  @@index([token_id])
}

model profile {
  id         String    @id
  address    String    @unique
  created_at DateTime  @default(now()) @db.Timestamptz(6)
  plan_type  plan_type
  image      String    @default("https://storage.googleapis.com/opensea-static/opensea-profile/10.png")

  // profile_setting profile_setting?
  @@index([address])
  @@index([plan_type])
}

// model profile_setting {
//   id         String  @id
//   profile_id String  @unique
//   settings   Json
//   profile    profile @relation(fields: [profile_id], references: [id], onDelete: Cascade)
// }

// quick models from old db
model mails {
  id         String   @id
  address    String   @unique
  email      String   @unique
  ip_address String
  timestamp  DateTime @default(now()) @db.Timestamptz(6)

  @@index([address])
  @@index([email])
}

model tradingview_chart {
  id               String   @id
  address          String
  resolution       String
  symbol           String
  contract_address String
  updated_at       DateTime @default(now()) @db.Timestamptz(6)
  content          Json
  name             String

  @@unique([address, resolution, symbol, contract_address])
  @@index([address])
  @@index([contract_address])
}

model stat {
  id         String     @id
  type       stats_type
  timestamp  DateTime   @default(now()) @db.Timestamptz(6)
  source     String?
  address    String?
  ip_address String?
  plan_type  plan_type?
  extra_data String?

  @@index([type])
  @@index([timestamp])
  @@index([plan_type])
}

//
// ENUMS
enum erc_type {
  ERC721
  ERC1155
}

enum listing_status {
  active
  inactive
  expired
  cancelled
  filled
}

enum sale_type {
  ask
  bid
}

enum stats_type {
  usage_time
  view
  login
  pnl_download
  partnership_comeback
  bought_pro
}

enum plan_type {
  free
  pro
  founder_pass
  partnership
}

enum transfer_type {
  burn
  transfer
}
